*** some reduce rules ***

filter p (map f xs)          =  mapFilter (p . f) f xs  =  map (\x -> if p (f x) then f x else None)
map f (filter p xs)          =  mapFilter p       f xs  =  map (\x -> if p x then f x else None)
filter p' (mapFilter p f xs) =  mapFilter (\x -> p x && p' x) f xs
map f' (mapFilter p f xs)    =  mapFilter p (f' . f) xs

head (mapFilter p f xs)      =  f (head (filter p xs))


List.build xs                ~ xs
SortedList.build comp xs     ~ sort comp xs
Array.build xs               ~ xs
SqrtDecArray.build f xs      ~ xs
FenwickTree.build xs         ~ xs
HashSet.build xs             ~ xs
TreeSet.build xs             ~ xs
Map.build f xs               ~ map f xs
HashTable.build f ks         ~ map (\k -> (k, f k)) ks
Heap.build comp xs           ~ sort comp xs

Map.get x xs         ~ (snd . head) ( filter (\(x1, _) -> x1 == x) xs )
HashTable.get x xs   ~ (snd . head) ( filter (\(x1, _) -> x1 == x) xs )
Heap.pop xs          ~ head xs


* f :: T -> Number
get= f v xs ~ filter (\x -> f x == v) xs
get< f v xs ~ filter (\x -> f x < v) xs
get> f v xs ~ filter (\x -> f x > v) xs

*** graph problem from cozy ***

record Edge { src: Int, dst: Int }
graph: SetOf<Edge>
query findEdges(n: int) = filter (\e -> e.src == n || e.dst == n) graph


* Solution O(n)
graphList: List<Edge>
findEdges n = filter (\e -> e.src == n || e.dst == n) graphList


* Solution O(n) with HashTable<Int, Edge>
table1: HashTable<Int, Edge>
table2: HashTable<Int, Edge>
findEdges n = List.concat (HashTable.get n table1) (HashTable.get n table2)
where
    table1 = HashTable.build (\src -> filter (\e -> e.src == src) graph) (map (\e -> e.src) graph)
    table2 = HashTable.build (\dst -> filter (\e -> e.dst == dst) graph) (map (\e -> e.dst) graph)


findEdges n ~
List.concat
    HashTable.get n ( HashTable.build (\src -> filter (\e -> e.src == src) graph) (map (\e -> e.src) graph) )
    HashTable.get n ( HashTable.build (\dst -> filter (\e -> e.dst == dst) graph) (map (\e -> e.dst) graph) ) ~
List.concat
    snd ( head ( filter (\(src, _) -> src == n) ( map (\k -> (k , filter (\e -> e.src == k) graph)) (map (\e -> e.src) graph) ) ) )
    snd ( head ( filter (\(dst, _) -> dst == n) ( map (\k -> (k , filter (\e -> e.dst == k) graph)) (map (\e -> e.dst) graph) ) ) ) ~
List.concat
    snd ( head ( filter (\(src, _) -> src == n) ( map (\e -> (e.src, filter (\e' -> e'.src == e.src) graph)) graph ) ) )
    snd ( head ( filter (\(dst, _) -> dst == n) ( map (\e -> (e.dst, filter (\e' -> e'.dst == e.dst) graph)) graph ) ) ) ~
List.concat
    snd ( head ( mapFilter (\e -> e.src == n) (\e -> (e.src, filter (\e' -> e'.src == e.src) graph)) graph ) )
    snd ( head ( mapFilter (\e -> e.dst == n) (\e -> (e.dst, filter (\e' -> e'.dst == e.dst) graph)) graph ) ) ~
List.concat
    snd ( (head (filter (\e -> e.src == n) graph)).src, filter (\e' -> e'.src == (head (filter (\e -> e.src == n) graph)).src) graph  )
    snd ( (head (filter (\e -> e.dst == n) graph)).dst, filter (\e' -> e'.dst == (head (filter (\e -> e.dst == n) graph)).dst) graph  ) ~
List.concat
    filter (\e' -> e'.src == (head (filter (\e -> e.src == n) graph)).src) graph
    filter (\e' -> e'.dst == (head (filter (\e -> e.dst == n) graph)).dst) graph ~
List.concat
    filter (\e' -> e'.src == n) graph
    filter (\e' -> e'.dst == n) graph ~
filter (\e -> e.src == n || e.dst == n) graph


Почему синтезатору стоит попробовать HashTable (эвристика)?
findEdges n ~
-- Разделим DNF(filter) по дизъюнктам
Collection.union
    filter (\e -> e.src == n) graph
    filter (\e -> e.dst == n) graph
Collection.union
    get= (\e -> e.src) n graph
    get= (\e -> e.dst) n graph
-- Для get= f n graph можно попробовать Map<K, V, f> в случае (inj f), иначе HashTable<K, V, f>
-- Solver проверяет, что данная f не inj
Collection.union
    HashTable.get n ( HashTable.build (\e) )




* Solution O(1) with HashTable<Int, Edge>
table1: HashTable<Int, Edge>
table2: HashTable<Int, Edge>
findEdges n = List.concat (HashTable.get n table1) (HashTable.get n table2)
where
    table1 = HashTable.build (\src -> filter (\e -> e.src == src) graph) (map (\e -> e.src) graph)
    table2 = HashTable.build (\dst -> filter (\e -> e.dst == dst) graph) (map (\e -> e.dst) (filiter (\e -> e.src != e.dst) graph))


findEdges n ~
List.concat
    HashTable.get n ( HashTable.build (\src -> filter (\e -> e.src == src) graph) (map (\e -> e.src) graph) )
    HashTable.get n ( HashTable.build (\dst -> filter (\e -> e.dst == dst) graph) (map (\e -> e.dst) (filiter (\e -> e.src != e.dst) graph)) ) ~
List.concat
    map snd ( filter (\(src, _) -> src == n) ( map (\k -> (k , filter (\e -> e.src == k) graph)) (map (\e -> e.src) graph) ) )
    map snd ( filter (\(dst, _) -> dst == n) ( map (\k -> (k , filter (\e -> e.dst == k) graph)) (mapFilter (\e -> e.src != e.dst) (\e -> e.dst) graph) ) ) ~
List.concat
    map snd ( filter (\(src, _) -> src == n) ( map (\e -> (e.src, filter (\e' -> e'.src == e.src) graph)) graph ) )
    map snd ( filter (\(dst, _) -> dst == n) ( mapFilter (\e -> e.src != e.dst) (\e -> (e.dst, filter (\e' -> e'.dst == e.dst) graph)) graph) ~
List.concat
    map snd ( mapFilter (\e -> e.src == n) (\e -> (e.src, filter (\e' -> e'.src == e.src) graph)) graph )
    map snd ( mapFilter (\e -> e.src != e.dst && e.dst == n) (\e -> (e.dst, filter (\e' -> e'.dst == e.dst) graph)) graph ) ~
List.concat
    mapFilter (\e -> e.src == n) (\e -> filter (\e' -> e'.src == e.src) graph) graph
    mapFilter (\e -> e.src != e.dst && e.dst == n) (\e -> filter (\e' -> e'.dst == e.dst) graph) graph ~
List.concat
    filter (\e -> e.src == n) graph
    filter (\e -> e.src != e.dst && e.dst == n) graph ~
filter (\e -> e.src == n || e.dst == n) graph




* Solution < O(n) with Map<Int, HashSet<Edge>>
table1: Map<Int, HashSet<Edge>>
table2: Map<Int, HashSet<Edge>>
findEdges n = Set.Union (Map.get n table1) (Map.get n table2)
where
    table1 = Map.build ( \e -> (e.src, filter (\e' -> e'.src == e.src) graph) ) graph
    table2 = Map.build ( \e -> (e.dst, filter (\e' -> e'.dst == e.dst) graph) ) graph


findEdges n ~
HashSet.union
    Map.get n ( Map.build ( \e -> (e.src, filter (\e' -> e'.src == e.src) graph) ) ) graph
    Map.get n ( Map.build ( \e -> (e.dst, filter (\e' -> e'.dst == e.dst) graph) ) ) graph ~
HashSet.union
    map snd ( filter (\(src, _) -> src == n) (map ( \e -> (e.src, filter (\e' -> e'.src == e.src) graph) ) graph) )
    map snd ( filter (\(dst, _) -> dst == n) (map ( \e -> (e.dst, filter (\e' -> e'.dst == e.dst) graph) ) graph) ) ~
HashSet.union
    map snd $ mapFilter (\e -> e.src == n) (\e -> (e.src, filter (\e' -> e'.src == e.src) graph)) graph
    map snd $ mapFilter (\e -> e.dst == n) (\e -> (e.dst, filter (\e' -> e'.dst == e.dst) graph)) graph ~
HashSet.union
    mapFilter (\e -> e.src == n) (\e -> filter (\e' -> e'.src == e.src) graph) graph
    mapFilter (\e -> e.dst == n) (\e -> filter (\e' -> e'.dst == e.dst) graph) graph ~
HashSet.union
    filter (\e -> e.src == n) graph
    filter (\e -> e.dst == n) graph ~
filter (\e -> e.src == n || e.dst == n) graph


* Solution O(1)
table1: Map<Int, HashSet<Edge>>
table2: Map<Int, HashSet<Edge>>
findEdges n = Set.Union (Map.get n table1) (Map.get n table2)
where
    table1 = Map.build ( \e -> (e.src, filter (\e' -> e'.src == e.src) graph) ) graph
    table2 = Map.build ( \e -> (e.dst, filter (\e' -> e'.dst == e.dst) graph) ) (filter (\e -> e.src != e.dst) graph)

let graph' = (filter (\e -> e.src != e.dst) graph)

findEdges n ~
HashSet.union
    Map.get n ( Map.build ( \e -> (e.src, filter (\e' -> e'.src == e.src) graph) ) ) graph
    Map.get n ( Map.build ( \e -> (e.dst, filter (\e' -> e'.dst == e.dst) graph) ) ) graph' ~
HashSet.union
    map snd ( filter (\(src, _) -> src == n) (map ( \e -> (e.src, filter (\e' -> e'.src == e.src) graph) ) graph) )
    map snd ( filter (\(dst, _) -> dst == n) (map ( \e -> (e.dst, filter (\e' -> e'.dst == e.dst) graph) ) graph') ) ~
HashSet.union
    map snd $ mapFilter (\e -> e.src == n) (\e -> (e.src, filter (\e' -> e'.src == e.src) graph)) graph
    map snd $ mapFilter (\e -> e.dst == n) (\e -> (e.dst, filter (\e' -> e'.dst == e.dst) graph)) graph' ~
HashSet.union
    mapFilter (\e -> e.src == n) (\e -> filter (\e' -> e'.src == e.src) graph) graph
    mapFilter (\e -> e.dst == n) (\e -> filter (\e' -> e'.dst == e.dst) graph) graph' ~
HashSet.union
    filter (\e -> e.src == n) graph
    filter (\e -> e.dst == n) graph' ~
HashSet.union
    filter (\e -> e.src == n) graph
    filter (\e -> e.dst == n) (filter (\e -> e.src != e.dst) graph) ~
HashSet.union
    filter (\e -> e.src == n) graph
    filter (\e -> e.dst == n && e.src != e.dst) graph ~
filter (\e -> e.src == n || (e.dst == n && e.src != e.dst)) graph ~
filter (\e -> e.src == n || e.dst == n) graph

-------------------------------------------------------------------------
*** top frequent word ***

record Word { value: String }
words: Collection<Word>
query count(val: String) = size (filter (\w -> w.value == val) words)
query topFrequent() =  maximize (\w -> count w.value) words

* Solution
wordsHeap: Heap<Word> (\w -> Map.get w countMap)
countMap: Map<Word, Int> (\w -> (w, count w.value))
topFrequent = Heap.pop wordsHeap

topFrequent ~
Heap.pop ( Heap.build (\w -> Map.get w (Map.build (\w1 -> (w1, count w.value)) words)) words ) ~
Heap.pop ( Heap.build (\w -> map snd $ filter (\(w1, _) -> w1 == w) (map (\w1 -> (w1, count w.value)) words)) words ) ~
Heap.pop ( Heap.build (\w -> map snd $ mapFilter (\w1 -> w1 == w) (\w1 -> (w1, count w1.value)) words) words ) ~
Heap.pop ( Heap.build (\w -> map snd $ (\w -> (w, count w.value)) words ) ~
Heap.pop ( Heap.build (\w -> count w.value) words ) ~
maximize (\w -> count w.value) words


* Solution
wordsList: List<Word>
topFrequent = List.maximize (\w -> count w.value) wordsList

topFrequent ~
List.maximize (\w -> count w.value) (List.build words) ~
maximize (\w -> count w.value) words


* Solution
wordsList: SortedDescList<Word> (\w -> count w.value)
topFrequent = List.head wordsList

topFrequent ~
List.head (SortedDescList.build (\w -> count w.value) words) ~
maximize (\w -> count w.value) words

-------------------------------------------------------------------------

