* Стандартные типы:
Number <- Int, Float
String
Bool

*** Внешние коллекции ***

* Collection<T>
map             :: (T -> T) -> Collection<T> -> Collection<T>
filter          :: (T -> Bool) -> Collection<T> -> Collection<T>
size            :: Collection<T> -> Int
maximize        :: (T -> Number) -> T
minimize        :: (T -> Number) -> T

* IndexedCollection<T>
map             :: (T -> T) -> IndexedCollection<T> -> IndexedCollection<T>
filter          :: (T -> Bool) -> IndexedCollection<T> -> IndexedCollection<T>
size            :: IndexedCollection<T> -> Int
maximize        :: (T -> Number) -> T
minimize        :: (T -> Number) -> T
get             :: Int -> IndexedCollection<T> -> T
foldl           :: (T' -> T -> T') -> T' -> T -> T'


*** Внутренние коллекции ***

** List-like **

* List<T>
List.build      :: [T] -> List<T>
List.head       :: List<T> -> T
List.tail       :: List<T> -> List<T>
List.last       :: List<T> -> T
List.map        :: (T -> T') -> List<T> -> List<T'>
List.filter     :: (T -> Bool) -> List<T> -> List<T>
List.sortAsc    :: (T -> Number) -> List<T> -> SortedAscList<T>
List.sortDesc   :: (T -> Number) -> List<T> ->  SortedDescList<T>
List.size       :: List<T> -> Int
List.maximize   :: (T -> Number) -> List<T> -> T
List.minimize   :: (T -> Number) -> List<T> -> T
List.add        :: T -> List<T> -> List<T>

* SortedAscList<T, (T -> Number)>
SortedAscList.build      :: (T -> Number) -> [T] -> SortedAscList<T>
SortedAscList.head       :: SortedAscList<T> -> T
SortedAscList.tail       :: SortedAscList<T> -> SortedAscList<T>
SortedAscList.last       :: SortedAscList<T> -> T
SortedAscList.map        :: (T -> T') -> SortedAscList<T> -> List<T'>
SortedAscList.filter     :: (T -> Bool) -> SortedAscList<T> -> SortedAscList<T>
SortedAscList.size       :: SortedAscList<T> -> Int
SortedAscList.maximize   :: (T -> Number) -> SortedAscList<T> -> T
SortedAscList.minimize   :: (T -> Number) -> SortedAscList<T> -> T
SortedAscList.add        :: T -> SortedAscList<T> -> SortedAscList<T>

* SortedDescList<T, (T -> Number)>
SortedDescList.build      :: (T -> Number) -> [T] -> SortedDescList<T>
SortedDescList.head       :: SortedDescList<T> -> T
SortedDescList.tail       :: SortedDescList<T> -> SortedDescList<T>
SortedDescList.last       :: SortedDescList<T> -> T
SortedDescList.map        :: (T -> T') -> SortedDescList<T> -> List<T'>
SortedDescList.filter     :: (T -> Bool) -> SortedDescList<T> -> SortedDescList<T>
SortedDescList.size       :: SortedDescList<T> -> Int
SortedDescList.maximize   :: (T -> Number) -> SortedDescList<T> -> T
SortedDescList.minimize   :: (T -> Number) -> SortedDescList<T> -> T
SortedDescList.add        :: T -> SortedDescList<T> -> SortedDescList<T>


** Array-like **

* Array<T>
Array.build     :: [T] -> Array<T>
Array.map       :: (T -> T') -> Array<T> -> Array<T'>
Array.size      :: Array<T> -> Int
Array.toList    :: Array<T> -> List<T>
Array.get       :: Int -> Array<T> -> T
Array.set       :: Int -> T -> Array<T>

* SqrtDecArray<T, assoc (T -> T')>
SqrtDecArray.build  :: (T -> T') -> Array<T> -> SqrtDecArray<T>
SqrtDecArray.eval   :: Int -> Int -> T'
SqrtDecArray.get    :: Int -> T
SqrtDecArray.set    :: Int -> T -> SqrtDecArray<T>

* FenwickTree<T, assoc comm invert (T -> T')>
FenwickTree.build   :: (T -> T') -> Array<T> -> FenwickTree<T>
FenwickTree.eval    :: Int -> Int -> T'
FenwickTree.get     :: Int -> T
FenwickTree.set     :: Int -> FenwickTree<T>


** Other **

* Set<T>
Set.build       :: [T] -> Set<T>
Set.filter      :: (T -> Bool) -> Set<T> -> Set<T>
Set.size        :: Set<T> -> Int
Set.contains    :: T -> Set<T> -> Bool
Set.maximize    :: (T -> Number) -> Set<T> -> T
Set.minimize    :: (T -> Number) -> Set<T> -> T
Set.add         :: T -> Set<T> -> Set<T>

* Map<K, V>
Map.build       :: (T -> (K, V)) -> [T] -> Map<K, V>
Map.filterK     :: (K -> Bool) -> Map<K, V> -> Map<K, V>
Map.filterV     :: (V -> Bool) -> Map<K, V> -> Map<K, V>
Map.size        :: Map<K, V> -> Int
Map.containsK   :: K -> Map<K, V> -> Bool
Map.containsV   :: V -> Map<K, V> -> Bool
Map.add         :: (K, V) -> Map<K, V> -> Map<K, V>

* Heap<T, (T -> Number)>
Heap.build      :: (T -> Number) -> [T] ->  Heap<T>
Heap.pop        :: Heap<T> -> Heap<T>
Heap.push       :: T -> Heap<T> -> Heap<T>
Heap.size       :: Heap<T> -> Int

* BinaryTree<T, (T -> Number)>
BinaryTree.build    :: (T -> Number) -> [T] -> BinaryTree<T>
BinaryTree.add      :: T -> BinaryTree<T> -> BinaryTree<T>
BinaryTree.remove   :: T -> BinaryTree<T> -> BinaryTree<T>
BinaryTree.contains :: T -> BinaryTree<T> -> Bool
BinaryTree.minimize :: BinaryTree<T> -> T
BinaryTree.maximize :: BinaryTree<T> -> T