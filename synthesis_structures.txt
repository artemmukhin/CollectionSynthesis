* Стандартные типы:
Number <- Int, Float
String
Bool

*** Внешние коллекции ***

* Collection<T>
map             :: (T -> T) -> Collection<T> -> Collection<T>
filter          :: (T -> Bool) -> Collection<T> -> Collection<T>
size            :: Collection<T> -> Int
maximize        :: (T -> Number) -> T
minimize        :: (T -> Number) -> T

* IndexedCollection<T>
map             :: (T -> T) -> IndexedCollection<T> -> IndexedCollection<T>
filter          :: (T -> Bool) -> IndexedCollection<T> -> IndexedCollection<T>
size            :: IndexedCollection<T> -> Int
maximize        :: (T -> Number) -> T
minimize        :: (T -> Number) -> T
get             :: Int -> IndexedCollection<T> -> T
foldl           :: (T' -> T -> T') -> T' -> T -> T'


*** Внутренние коллекции ***

** List-like **

* List<T>
List.build      :: [T] -> List<T>
List.head       :: List<T> -> T                                         O(1)
List.tail       :: List<T> -> List<T>                                   O(1)
List.last       :: List<T> -> T                                         O(1)
List.map        :: (T -> T') -> List<T> -> List<T'>                     O(n)
List.filter     :: (T -> Bool) -> List<T> -> List<T>                    O(n)
List.sortAsc    :: (T -> Number) -> List<T> -> SortedAscList<T>         O(n * log n)
List.sortDesc   :: (T -> Number) -> List<T> ->  SortedDescList<T>       O(n * log n)
List.size       :: List<T> -> Int                                       O(1)
List.maximize   :: (T -> Number) -> List<T> -> T                        O(n)
List.minimize   :: (T -> Number) -> List<T> -> T                        O(n)
List.contains   :: T -> List<T> -> Bool                                 O(n)
List.add        :: T -> List<T> -> List<T>                              O(1)

* SortedAscList<T, (T -> Number)>
SortedAscList.build      :: (T -> Number) -> [T] -> SortedAscList<T>                
SortedAscList.head       :: SortedAscList<T> -> T                                   O(1)
SortedAscList.tail       :: SortedAscList<T> -> SortedAscList<T>                    O(1)
SortedAscList.last       :: SortedAscList<T> -> T                                   O(1)
SortedAscList.map        :: (T -> T') -> SortedAscList<T> -> List<T'>               O(n)
SortedAscList.filter     :: (T -> Bool) -> SortedAscList<T> -> SortedAscList<T>     O(n)
SortedAscList.size       :: SortedAscList<T> -> Int                                 O(1)
SortedAscList.maximize   :: (T -> Number) -> SortedAscList<T> -> T                  O(n)
SortedAscList.minimize   :: (T -> Number) -> SortedAscList<T> -> T                  O(n)
SortedAscList.contains   :: T -> SortedAscList<T> -> Bool                           O(log n)
SortedAscList.add        :: T -> SortedAscList<T> -> SortedAscList<T>               O(log n)

* SortedDescList<T, (T -> Number)>
SortedDescList.build      :: (T -> Number) -> [T] -> SortedDescList<T>
SortedDescList.head       :: SortedDescList<T> -> T                                 O(1)
SortedDescList.tail       :: SortedDescList<T> -> SortedDescList<T>                 O(1)
SortedDescList.last       :: SortedDescList<T> -> T                                 O(1)
SortedDescList.map        :: (T -> T') -> SortedDescList<T> -> List<T'>             O(n)
SortedDescList.filter     :: (T -> Bool) -> SortedDescList<T> -> SortedDescList<T>  O(n)
SortedDescList.size       :: SortedDescList<T> -> Int                               O(1)
SortedDescList.maximize   :: (T -> Number) -> SortedDescList<T> -> T                O(n)
SortedDescList.minimize   :: (T -> Number) -> SortedDescList<T> -> T                O(n)
SortedDescList.contains   :: T -> SortedDescList<T> -> Bool                         O(log n)
SortedDescList.add        :: T -> SortedDescList<T> -> SortedDescList<T>            O(log n)


** Array-like **

* Array<T>
Array.build     :: [T] -> Array<T>
Array.map       :: (T -> T') -> Array<T> -> Array<T'>               O(n)
Array.size      :: Array<T> -> Int                                  O(1)
Array.toList    :: Array<T> -> List<T>                              O(n)
Array.get       :: Int -> Array<T> -> T                             O(1)
Array.set       :: Int -> T -> Array<T>                             O(1)

* SqrtDecArray<T, assoc (T -> T')>
SqrtDecArray.build  :: (T -> T') -> Array<T> -> SqrtDecArray<T>     O(n)
SqrtDecArray.eval   :: Int -> Int -> T'                             O(sqrt n)
SqrtDecArray.get    :: Int -> T                                     O(1)
SqrtDecArray.set    :: Int -> T -> SqrtDecArray<T>                  O(1) / O(n)  (comm invert?)

* FenwickTree<T, assoc comm invert (T -> T')>
FenwickTree.build   :: (T -> T') -> Array<T> -> FenwickTree<T>      O(n * log n)
FenwickTree.eval    :: Int -> Int -> T'                             O(log n)
FenwickTree.get     :: Int -> T                                     O(1)
FenwickTree.set     :: Int -> FenwickTree<T>                        O(log n)


** Other **

* HashSet<T>
Set.build       :: [T] -> Set<T>
Set.filter      :: (T -> Bool) -> Set<T> -> Set<T>      O(n)
Set.size        :: Set<T> -> Int                        O(1)
Set.contains    :: T -> Set<T> -> Bool                  O(1)
Set.maximize    :: (T -> Number) -> Set<T> -> T         O(n)
Set.minimize    :: (T -> Number) -> Set<T> -> T         O(n)
Set.add         :: T -> Set<T> -> Set<T>                

* TreeSet<T>
Set.build       :: [T] -> Set<T>
Set.filter      :: (T -> Bool) -> Set<T> -> Set<T>      
Set.size        :: Set<T> -> Int                        O(1)
Set.contains    :: T -> Set<T> -> Bool                  O(log n)
Set.maximize    :: (T -> Number) -> Set<T> -> T         O(log n)
Set.minimize    :: (T -> Number) -> Set<T> -> T         O(log n)
Set.add         :: T -> Set<T> -> Set<T>

* Map<K, V>
Map.build       :: (T -> (K, V)) -> [T] -> Map<K, V>
Map.filterK     :: (K -> Bool) -> Map<K, V> -> Map<K, V>
Map.filterV     :: (V -> Bool) -> Map<K, V> -> Map<K, V>
Map.size        :: Map<K, V> -> Int
Map.containsK   :: K -> Map<K, V> -> Bool
Map.containsV   :: V -> Map<K, V> -> Bool
Map.add         :: (K, V) -> Map<K, V> -> Map<K, V>

* Heap<T, (T -> Number)>
Heap.build      :: (T -> Number) -> [T] ->  Heap<T>
Heap.pop        :: Heap<T> -> Heap<T>
Heap.push       :: T -> Heap<T> -> Heap<T>
Heap.size       :: Heap<T> -> Int

* BinaryTree<T, (T -> Number)>
BinaryTree.build    :: (T -> Number) -> [T] -> BinaryTree<T>
BinaryTree.add      :: T -> BinaryTree<T> -> BinaryTree<T>
BinaryTree.remove   :: T -> BinaryTree<T> -> BinaryTree<T>
BinaryTree.contains :: T -> BinaryTree<T> -> Bool
BinaryTree.minimize :: BinaryTree<T> -> T
BinaryTree.maximize :: BinaryTree<T> -> T