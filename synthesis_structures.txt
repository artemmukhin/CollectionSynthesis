* Стандартные типы:
Number <- Int, Float
String
Bool

*** Внешние коллекции ***

* Collection<T>
map             :: (T -> T) -> Collection<T> -> Collection<T>
filter          :: (T -> Bool) -> Collection<T> -> Collection<T>
size            :: Collection<T> -> Int
maximize        :: (T -> Number) -> T
minimize        :: (T -> Number) -> T

* IndexedCollection<T>
map             :: (T -> T) -> IndexedCollection<T> -> IndexedCollection<T>
filter          :: (T -> Bool) -> IndexedCollection<T> -> IndexedCollection<T>
size            :: IndexedCollection<T> -> Int
maximize        :: (T -> Number) -> T
minimize        :: (T -> Number) -> T
get             :: Int -> IndexedCollection<T> -> T
foldl           :: (T' -> T -> T') -> T' -> T -> T'


*** Внутренние коллекции ***

** List-like **

* List<T>
List.build      :: [T] -> List<T>
List.head       :: List<T> -> T                                         O(1)
List.tail       :: List<T> -> List<T>                                   O(1)
List.last       :: List<T> -> T                                         O(1)
List.map        :: (T -> T') -> List<T> -> List<T'>                     O(n)
List.filter     :: (T -> Bool) -> List<T> -> List<T>                    O(n)
List.sortAsc    :: (T -> Number) -> List<T> -> SortedList<T>            O(n * log n)
List.sortDesc   :: (T -> Number) -> List<T> ->  SortedList<T>           O(n * log n)
List.size       :: List<T> -> Int                                       O(1)
List.maximize   :: (T -> Number) -> List<T> -> T                        O(n)
List.minimize   :: (T -> Number) -> List<T> -> T                        O(n)
List.contains   :: T -> List<T> -> Bool                                 O(n)
List.add        :: T -> List<T> -> List<T>                              O(1)
List.concat     :: List<T> -> List<T> -> List<T>                        O(1)

* SortedList<T, (T -> Number)>
SortedList.build      :: (T -> Number) -> [T] -> SortedList<T>                
SortedList.head       :: SortedList<T> -> T                             O(1)
SortedList.tail       :: SortedList<T> -> SortedList<T>                 O(1)
SortedList.last       :: SortedList<T> -> T                             O(1)
SortedList.map        :: (T -> T') -> SortedList<T> -> List<T'>         O(n)
SortedList.filter     :: (T -> Bool) -> SortedList<T> -> SortedList<T>  O(n)
SortedList.size       :: SortedList<T> -> Int                           O(1)
SortedList.maximize   :: (T -> Number) -> SortedList<T> -> T            O(n)
SortedList.minimize   :: (T -> Number) -> SortedList<T> -> T            O(n)
SortedList.find       :: T -> SortedList<T> -> T                        O(log n)
SortedList.contains   :: T -> SortedList<T> -> Bool                     O(log n)
SortedList.add        :: T -> SortedList<T> -> SortedList<T>            O(log n)


** Array-like **

* Array<T>
Array.build     :: [T] -> Array<T>
Array.map       :: (T -> T') -> Array<T> -> Array<T'>               O(n)
Array.size      :: Array<T> -> Int                                  O(1)
Array.toList    :: Array<T> -> List<T>                              O(n)
Array.get       :: Int -> Array<T> -> T                             O(1)
Array.set       :: Int -> T -> Array<T>                             O(1)

* SqrtDecArray<T, assoc (T -> T')>
SqrtDecArray.build  :: (T -> T') -> Array<T> -> SqrtDecArray<T>     O(n)
SqrtDecArray.eval   :: Int -> Int -> T'                             O(sqrt n)
SqrtDecArray.get    :: Int -> T                                     O(1)
SqrtDecArray.set    :: Int -> T -> SqrtDecArray<T>                  O(1) / O(n)  (comm invert?)

* FenwickTree<T, assoc comm invert (T -> T')>
FenwickTree.build   :: (T -> T') -> Array<T> -> FenwickTree<T>      O(n * log n)
FenwickTree.eval    :: Int -> Int -> T'                             O(log n)
FenwickTree.get     :: Int -> T                                     O(1)
FenwickTree.set     :: Int -> FenwickTree<T>                        O(log n)


** Other **

* HashSet<T>
HashSet.build       :: [T] -> HashSet<T>
HashSet.filter      :: (T -> Bool) -> HashSet<T> -> HashSet<T>      O(n)
HashSet.size        :: HashSet<T> -> Int                            O(1)
HashSet.find        :: T -> HashSet<T>                              O(1)
HashSet.contains    :: T -> HashSet<T> -> Bool                      O(1)
HashSet.maximize    :: (T -> Number) -> HashSet<T> -> T             O(n)
HashSet.minimize    :: (T -> Number) -> HashSet<T> -> T             O(n)
HashSet.add         :: T -> HashSet<T> -> HashSet<T>                
HashSet.union       :: HashSet<T> -> HashSet<T> -> HashSet<T>       O(n)

* TreeSet<T>
TreeSet.build       :: [T] -> TreeSet<T>
TreeSet.filter      :: (T -> Bool) -> TreeSet<T> -> TreeSet<T>      
TreeSet.size        :: TreeSet<T> -> Int                            O(1)
TreeSet.contains    :: T -> TreeSet<T> -> Bool                      O(log n)
TreeSet.maximize    :: (T -> Number) -> TreeSet<T> -> T             O(log n)
TreeSet.minimize    :: (T -> Number) -> TreeSet<T> -> T             O(log n)
TreeSet.add         :: T -> TreeSet<T> -> TreeSet<T>

* Map<K, V>
Map.build           :: (K -> V) -> [K] -> Map<K, V>
Map.filterK         :: (K -> Bool) -> Map<K, V> -> Map<K, V>
Map.filterV         :: (V -> Bool) -> Map<K, V> -> Map<K, V>
Map.size            :: Map<K, V> -> Int
Map.containsK       :: K -> Map<K, V> -> Bool
Map.containsV       :: V -> Map<K, V> -> Bool
Map.get             :: K -> Map<K, V> -> V
Map.add             :: (K, V) -> Map<K, V> -> Map<K, V>

* HashTable<K, V>
HashTable.build       :: (K -> [V]) -> [K] -> HashTable<K, V>
HashTable.filterK     :: (K -> Bool) -> HashTable<K, V> -> HashTable<K, V>
HashTable.size        :: HashTable<K, V> -> Int
HashTable.containsK   :: K -> HashTable<K, V> -> Bool
HashTable.containsV   :: V -> HashTable<K, V> -> Bool
HashTable.get         :: K -> HashTable<K, V> -> List<V>
HashTable.add         :: (K, V) -> HashTable<K, V> -> HashTable<K, V>

* Heap<T, (T -> Number)>
Heap.build      :: (T -> Number) -> [T] ->  Heap<T>
Heap.pop        :: Heap<T> -> Heap<T>
Heap.push       :: T -> Heap<T> -> Heap<T>
Heap.size       :: Heap<T> -> Int

* BinaryTree<T, (T -> Number)>
BinaryTree.build    :: (T -> Number) -> [T] -> BinaryTree<T>
BinaryTree.add      :: T -> BinaryTree<T> -> BinaryTree<T>
BinaryTree.remove   :: T -> BinaryTree<T> -> BinaryTree<T>
BinaryTree.contains :: T -> BinaryTree<T> -> Bool
BinaryTree.minimize :: BinaryTree<T> -> T
BinaryTree.maximize :: BinaryTree<T> -> T