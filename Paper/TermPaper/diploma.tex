\documentclass[14pt]{matmex-diploma-custom}

\usepackage{syntax}
\usepackage{listings}
\usepackage[section]{placeins}
\usepackage{float}

\lstdefinelanguage{SyGuSLang}
{
  morekeywords={ Int, String, Bool, List, Map, Set, Obj, Func, map, filter, mapFilter },
  morecomment=[s]{/*}{*/}, % s is for start and end delimiter
  morestring=[b]" % defines that strings are enclosed in double quotes
}

\lstdefinelanguage{SolutionLang}
{
  morekeywords={ Int, String, Bool, List, Map, Set, filter, map, mapFilter, where, let},
  morecomment=[l]{--}, % l is for line comment
  morecomment=[s]{/*}{*/}, % s is for start and end delimiter
  morestring=[b]" % defines that strings are enclosed in double quotes
}

\lstdefinelanguage{CollectionLang}
{
  morekeywords={ Int, String, Bool, List, HashMap, HashSet, FenwickTree, Array, Heap, Set, Map, map, filter, mapFilter },
  morecomment=[l]{--}, % l is for line comment
  morecomment=[s]{/*}{*/}, % s is for start and end delimiter
  morestring=[b]" % defines that strings are enclosed in double quotes
}

\lstdefinelanguage{Synthesizer}
{
  morekeywords={ Int, String, Bool, record, Collection, query, update, or, and, of },
  morecomment=[l]{--}, % l is for line comment
  morecomment=[s]{/*}{*/}, % s is for start and end delimiter
  morestring=[b]" % defines that strings are enclosed in double quotes
}
\lstdefinestyle{Synth} {
    language        = Synthesizer,
    basicstyle      = \footnotesize\ttfamily,
    identifierstyle = \color{black},
    commentstyle    = \color{green},
    keywordstyle    = \color{blue},
    stringstyle     = \color{red},
    extendedchars   = true,
    tabsize         = 4,
    showspaces      = false,
    showstringspaces = false,
    breakautoindent = true,
    flexiblecolumns = true,
    keepspaces      = true,
    stepnumber      = 0,
    xleftmargin     = 0pt
}
\lstset{
    style=Synth,
    breaklines=false,
    frame=none
}



\begin{document}
% Год, город, название университета и факультета предопределены,
% но можно и поменять.
% Если англоязычная титульная страница не нужна, то ее можно просто удалить.
\filltitle{ru}{
    chair              = {Кафедра системного программирования},
    title              = {Синтез структур данных},
    % Здесь указывается тип работы. Возможные значения:
    %   coursework - Курсовая работа
    %   diploma - Диплом специалиста
    %   master - Диплом магистра
    %   bachelor - Диплом бакалавра
    type               = {coursework},
    position           = {студента},
    group              = 344,
    author             = {Мухин Артем Михайлович},
    supervisorPosition = {ст. преп.},
    supervisor         = {Кириленко Я.\,А.},
    reviewerPosition   = {программист JetBrains},
    reviewer           = {Мордвинов Д.\,А.},
    chairHeadPosition  = {профессор},
    chairHead          = {Терехов А.\,Н.},
%   university         = {Санкт-Петербургский Государственный Университет},
%   faculty            = {Математико-механический факультет},
%   city               = {Санкт-Петербург},
%   year               = {2013}
}
%\filltitle{en}{
%    chair              = {Software Engineering Chair},
%    title              = {Data Structure Synthesis},
%    author             = {Artem Mukhin},
%    supervisorPosition = {},
%    supervisor         = {Dmitry Mordvinov},
%    reviewerPosition   = {},
%    reviewer           = {},
%    chairHeadPosition  = {professor},
%    chairHead          = {Andrey Terekhov},
%}
\maketitle
\tableofcontents
% У введения нет номера главы
\section*{Введение}
Во многих программах используются специальные структуры данных, не содержащиеся явно в стандартных библиотеках языков программирования. Таковыми являются структуры, составленные из известных коллекций с помощью композиции или изменения некоторых свойств. Реализация таких структур --- монотонная и сложная работа, в ходе которой зачастую возникают ошибки как на этапе подбора оптимальных структур (т.к для этого программисту необходимо знать асимптотики различных операций над структурами данных), так и на этапе реализации.

Существуют инструменты, позволяющие автоматически подбирать оптимальные реализации структур данных~\cite{RelC, Lambda2, Cozy}. Часть из них использует синтез программного кода. Синтез программ --- это задача автоматического поиска программы, написанной на заданном языке программирования и удовлетворяющей некоторым ограничениям, которые задает пользователь. Ограничения на требуемую программу могут быть спецификацией на некотором промежуточном языке, примерами ввода-вывода, описанием на естественном языке, частично написанными программами и так далее. Синтезатор структур данных --- это инструмент, позволяющий получить реализацию (на заданном пользователем языке программирования) автоматически сконструированной структуры данных. Спецификации структур данных часто представляют собой описания на некотором декларативном языке, поскольку такой вид спецификации достаточно выразителен и удобен для пользователя.

В последние годы было предпринято несколько попыток создать синтезаторы структур данных~\cite{Cozy}. Однако класс задач, решаемый ими, ограничен.
%Однако существующие синтезаторы еще далеки от совершенства: они позволяют создавать структуры данных только для определенного узкого класса задач (например, структуры данных с запросами-фильтрациями).
Усовершенствование текущих подходов к синтезу структур данных является актуальной проблемой.



\section{Постановка задачи}
Целью данной работы является создание синтезатора структур данных, подходящего для более широкого класса задач, чем существующие. Для достижения этой цели были поставлены следующие задачи:
\begin{itemize}
    \item исследовать существующие подходы к синтезу программ;
    \item спроектировать декларативный язык спецификации структур данных, достаточно мощный для описания нетривиальных задач;
    \item разработать алгоритм синтеза структур данных;
    \item разработать прототип ядра синтезатора.
\end{itemize}



\section{Обзор}
Синтез программ является одной из наиболее значимых проблем информатики и искусственного интеллекта. Успешное решение этой задачи требует преодоления двух основных проблем:
\begin{enumerate}
    \item Необходимо предоставить пользователю достаточно простой и удобный способ спецификации желаемой программы, который не был бы слишком сложен для компьютера.
    \item Синтез программ --- сложнейшая комбинаторная проблема; во избежание взрыва количества программ приходится как можно сильнее сокращать пространство перебора.
\end{enumerate}

Исторически реализация синтезаторов программ стала возможной после появления инструментов для автоматического доказательства теорем.

Рассмотрим некоторые подходы к синтезу программ.

\subsection{Дедуктивный синтез}
Первые подходы~\cite{deductive1, Zohar} к синтезу программ были основаны на дедукции. Идея \emph{дедуктивного синтеза} --- автоматически доказать заданную пользователем спецификацию и затем использовать это доказательство для конструирования подходящей программы. Основной минус этого подхода заключается в том, что пользователю приходится составлять полную и формальную спецификацию, что во многих случаях не проще написания требуемой программы вручную.

\subsection{Индуктивный синтез}
Позже был придуман метод индуктивного синтеза, который позволяет вместо полных спецификаций программы использовать индуктивные ограничения, такие как примеры ввода-вывода и демонстрации работы программы. В 1970-е годы этот подход был реализован в нескольких инструментах для синтеза небольших программ на языке LISP~\cite{Shaw}. Сегодня для синтеза программ чаще применяют техники, сочетающие в себе и дедуктивный, и индуктивный подходы~\cite{ProgramSynthesis}.

\subsection{Синтез, управляемый оракулом}
Одним из современных подходов к синтезу программ является синтез на основе \emph{частично написанных программ} (программ с <<дырками>>). В качестве спецификации желаемой программы выступает некоторый каркас, содержащий <<заглушки>>, реализацию которых должен найти синтезатор, а также ограничения в виде \emph{утверждений} (assertions), которым должна удовлетворять итоговая программа. Первой известной реализацией этого подхода является инструмент Sketch~\cite{Solar-Lezama}, созданный в 2008 году.

Синтез программ, реализованный в Sketch, основывается на верификации программ-кандидатов, полученных генератором произвольных программ на фиксированном языке. Для каждого очередного кандидата требуется найти контрпример, который в дальнейшем используется как дополнительное ограничение на искомую программу. Такой подход получил название CEGIS (counterexample-guided inductive synthesis). Позже этот подход был обобщён до OGIS~\cite{Jha} (oracle-guided inductive synthesis). В OGIS синтезатор сначала ищет программу-кандидата с использованием упрощенной спецификации, а затем оракул проверяет правильность кандидата (например, в CEGIS оракул проверяет соответствие кандидата логической формуле).

\begin{figure}[H]
\caption{Архитектура CEGIS (изображение взято из \cite{Solar-Lezama})}
\centering
\includegraphics[width=0.87\textwidth]{OGIS}
\end{figure}


% Важнейшей находкой автора Sketch является следующее наблюдение: в отличие от синтеза, задачи второго порядка, верификация программ является задачей первого порядка и решается гораздо проще. При этом задача синтеза программы сводится к верификации программ, полученных генератором произвольных программ на фиксированном языке. Для каждого очередного кандидата требуется найти конструктивный контрпример, который в дальнейшем используется как дополнительное ограничение на искомую программу. Такой подход получил название \emph{CEGIS} (counterexample-guided inductive synthesis).

\subsection{Инструмент ${\lambda}^2$}
Также стоит упомянуть инструмент для синтеза преобразований списков ${\lambda}^2$~\cite{Lambda2}. Этот синтезатор принимает на вход несколько примеров преобразований списка или дерева и возвращает функцию, удовлетворяющую этим примерам. ${\lambda}^2$ обладает достаточной мощностью, чтобы синтезировать весьма нетривиальные операции, такие как декартово произведение списков и удаление дубликатов из списка. Данная работа интересна тем, что сочетает сразу несколько техник синтеза: индукцию для обобщения входных примеров; дедукцию для опровержения и генерации новых примеров; заполнение <<дырок>> в промежуточных программах-кандидатах.

\subsection{Подход Syntax-Guided Synthesis}
Было замечено, что многие задачи синтеза программ можно существенно упростить, если использовать спецификации двух типов: синтаксическую и семантическую. Синтаксическая спецификация представляет собой грамматику искомой программы, а семантическая спецификация --- ограничения в терминах логики первого порядка. Подход SyGuS~\cite{SyGuS} реализует эту идею. Каждый год проводятся соревнования SyGuS-решателей~\cite{SyGuScomp15, SyGuScomp16, SyGuScomp17}.

\subsection{Синтез структур данных}
Синтез структур данных подразумевает собой автоматическую реализацию структуры данных, сконструированной согласно пользовательской спецификации. При этом синтезатор осуществляет перебор и выбор подходящего (и, в некоторых случаях, оптимального по асимптотическим или другим свойствам) варианта среди зафиксированного пространства структур данных.

В 1970-е годы задача выбора оптимальной реализации структуры данных была рассмотрена во время проектирования языка SETL~\cite{setl}. Язык SETL предоставляет два основных агрегатных типа данных: неупорядоченные множества и кортежи. Элементы множеств и кортежей могут быть любого произвольного типа (включая агрегатные типы). Также в этом языке есть словари, которые представляются в виде множества пар (т.е. кортежей из двух элементов). При этом неупорядоченное множество и словарь --- это интерфейсы, у которых существует множество реализаций (на основе хэш-таблиц и различных деревьев). Для улучшения производительности программ, написанных на SETL, требовалось выбирать наиболее оптимальные для конкретных задач реализации этих интерфейсов во время исполнения программы.

Кроме того, были попытки синтезировать структуры данных с помощью реляционной алгебры. Так, авторы RelC~\cite{RelC} использовали реляционные спецификации для синтеза структур данных на основе реализаций из библиотек STL (C++ Standard Template Library) и Boost. RelC был протестирован на задачах над графами из некоторых проектов с открытым исходным кодом и показал прирост производительности по сравнению с оригинальными реализациями.

Авторы синтезатора структур данных Cozy~\cite{Cozy} предложили подход к синтезу структур данных, основанный на CEGIS. Cozy успешно решает некоторый узкий круг задач, а именно --- фильтрацию элементов коллекции по предикатам, содержащим только имена переменных и полей и знаки сравнения.
С помощью Cozy работа программиста сводится к описанию требуемой ему структуры данных на языке спецификации высокого уровня. Грамматика этого языка представлена ниже:

\begin{grammar}
<predicate> ::= True | False 
\alt <var> <comparison> <var> 
\alt <predicate> And <predicate> \alt <predicate> Or <predicate>
\alt Not <predicate>
\end{grammar}

\begin{grammar}
<var> ::= <field> | <query-var>
\end{grammar}

\begin{grammar}
<comparison> ::= `==' | `>' | `>=' | `<' | `<=' | `!='
\end{grammar}
Этот язык имеет несколько проблем. Во-первых, в спецификациях возможны только запросы-фильтрации (поиск элементов коллекции, удовлетворяющих предикату), поэтому на этом языке нельзя описать выполнение каких-либо действий над элементами. Во-вторых, язык Cozy не поддерживает арифметику. Оракулы, используемые в синтезаторах, обычно основаны на SMT-решателях (программах, решающих задачу выполнимости формулы в теориях). Учитывая мощности современных SMT-решателей, добавление линейной арифметики выглядит возможным.


% Работа, представляющая для нас наибольший интерес, --- это синтезатор структур данных Cozy~\cite{Cozy}. Авторы данной работы предложили подход к синтезу структур данных, основанный на идее CEGIS. С помощью Cozy работа программиста сводится к описанию требуемой ему структуры данных на языке спецификации высокого уровня, а поиск и реализацию подходящих структур данных берет на себя синтезатор. Cozy имеет довольно скудный язык спецификации и способен решать некоторые несложные задачи, а именно --- фильтрацию элементов коллекции по предикатам, содержащим только имена переменных, полей и знаки сравнения.


\section{Решение}
В данной главе описывается процесс проектирования и разработки прототипа ядра --- части синтезатора, ответственной за поиск искомой структуры данных по пользовательской спецификации.

\subsection{Архитектура синтезатора}
Данная курсовая работа посвящена созданию ядра (\textit{kernel}) синтезатора, а создание генератора кода и реализация структур данных остается за её рамками. На рисунке представлена архитектура будущего синтезатора.
\begin{figure}[h]
\caption{Архитектура синтезатора}
\centering
\includegraphics[width=0.6\textwidth]{ud3}
\end{figure}

\subsection{Язык спецификации}
Перед началом проектирования языка спецификации структур данных, была собрана некоторая коллекция задач, потенциально подходящих для синтеза. Были выбраны несколько алгоритмически простых задач на нетривиальные структуры данных: дерево отрезков, декартово дерево, корневая декомпозиция отрезка, а также на более известные коллекции: хэш-таблица, приоритетная очередь, дерево поиска, ассоциативные контейнеры.

На основе этих задач необходимо было понять, как могли бы выглядеть спецификации (т.е. формальные описания задач) и, соответственно, какие возможности должен поддерживать язык спецификаций. Было замечено следующее:
\begin{itemize}
    \item в задачах обычно требуются коллекции, элементами которых в общем случае бывают записи из нескольких элементов примитивных типов;
    \item действия над структурами данных удобно представлять в виде \textit{запросов} --- функций, которые принимают примитивные входные параметры и возвращают какие-то элементы структуры данных (например, все элементы, удовлетворяющие какому-то свойству) или примитивные значения (например, количество элементов);
    \item сами запросы удобно записывать в функциональном стиле с применением комбинаторов $filter$, $map$ и $fold$.
\end{itemize}

 Упрощенный вид грамматики спроектированного языка приведен ниже:

\begin{figure}[H]
\begin{minipage}{\linewidth}

\[
\begin{array}{rcl}
Specification  & ::= &  RecordDecl^* ~~ CollectionDecl^* ~~ Query^*  \\
RecordDecl     & ::= &  \texttt{\underline{record}} ~~ Name ~~ \texttt{\underline{\{}}~ Field^* ~\texttt{\underline{\}}}            \\
CollectionDecl & ::= &  Name~ \texttt{\underline{:}}~ \texttt{\underline{Collection}} \texttt{\underline{<}}Name\texttt{\underline{>}}                      \\
Field          & ::= &  Name~ \texttt{\underline{:}}~ Type                                  \\
Query          & ::= &  \texttt{\underline{query}} ~~ Name \texttt{\underline{(}}~ Parameter^* ~\texttt{\underline{)}}~ \texttt{\underline{=}}~ Body       \\
Body           & ::= &  Name ~|~ Func ~ Body                        \\
Func           & ::= &  \texttt{\underline{filter}} ~ f ~|~ \texttt{\underline{map}} ~ f                           \\
Parameter      & ::= &  Name : Type                                  \\
Type           & ::= &  \texttt{\underline{Int}} ~|~ \texttt{\underline{Float}} ~|~ \texttt{\underline{Bool}} \\

f              & ::= &  \texttt{\underline{(}}~ \texttt{\underline{$\lambda$}} ~Name~ \texttt{\underline{$\to$}} ~SimpleExpr~ \texttt{\underline{)}} \\

SimpleExpr     & ::= &  ArithExpr ~|~ LogExpr \\

ArithExpr      & ::= &  Term~ ((\texttt{\underline{+}} ~|~ \texttt{\underline{-}}) ~Term)^* \\

Term           & ::= &  Factor~ ((\texttt{\underline{*}} ~|~ \texttt{\underline{/}}) ~Factor)^* \\

Factor         & ::= &  \texttt{\underline{-}} Atom ~|~ Atom \\

Atom           & ::= &  Name ~|~ Name\texttt{\underline{.}}Name ~|~ Number ~|~ \texttt{\underline{(}} ArithExpr \texttt{\underline{)}} \\

LogExpr        & ::= & SimpleLog ~|~ SimpleLog ~RelOp~ SimpleLog \\

SimpleLog  & ::= &  LogTerm~ (\texttt{\underline{||}} ~LogTerm)^* \\

LogTerm      & ::= &  LogFactor~ (\texttt{\underline{\&\&}} ~LogFactor)^* \\

LogFactor    & ::= &  \texttt{\underline{!}} LogAtom ~|~ LogAtom \\

LogAtom           & ::= &  Name ~|~ Name\texttt{\underline{.}}Name ~|~ \texttt{\underline{true}} ~|~ \texttt{\underline{false}}  ~|~ \texttt{\underline{(}} LogExpr \texttt{\underline{)}} \\

RelOp        & ::= &  \texttt{\underline{>}} ~|~ \texttt{\underline{<}} ~|~ \texttt{\underline{<=}} ~|~ \texttt{\underline{>=}} ~|~ \texttt{\underline{==}} ~|~ \texttt{\underline{!=}} \\

\end{array}
\]

\end{minipage}
\caption{Грамматика языка спецификации}
\end{figure}

Спецификация состоит из объявлений типов записей (элементов коллекций) и типов коллекций, а также из определений запросов к коллекциям. Синтаксис определения запросов во многом подобен синтаксису языка Haskell. Пользователь может использовать комбинаторы $filter$ и $map$, передавая в них функции, содержащие арифметические операторы, сравнение, использование значений полей записей и параметров запроса.

Для демонстрации возможностей языка рассмотрим задачу поиска инцидентных данной вершине дуг в графе, спецификация которой приведена в Листинге~\ref{lst:graph}.

\begin{lstlisting}[caption={Поиск инцидентных данной вершине дуг в графе}, captionpos=t, label={lst:graph}, mathescape=true, frame=none]
record Edge { src: Int, dst: Int }
graph: Collection<Edge>
query findEdges(node: Int) =
    filter ($\lambda$edge $\to$ edge.src == node || edge.dst == node) graph
\end{lstlisting}

В этой спецификации вводится некоторая коллекция $graph$, состоящая из записей, соответствующих ребрам графа. Далее определяется запрос, результатом выполнения которого является набор рёбер, инцидентных данной вершине.


\subsection{Поддержка структур данных}
Синтезатор выполняет перебор различных структур данных, чтобы найти среди них нужную. Для ограничения пространства перебора необходимо зафиксировать множество структур данных, которые он потенциально будет поддерживать. Таковыми являются: список, хэш-таблица и другие стандартные коллекции, а также некоторые нестандартные: дерево отрезков~\cite{Bentley1977}, дерево Фенвика~\cite{Fenwick}, корневая декомпозиция~\cite{RootDec} и некоторые другие. Все эти структуры данных удобно описывать как совокупности функций над этими коллекциями. Типизация этих функций позволяет отсечь заведомо некорректные по типам программы. Пример такой типизации показан ниже (для структур данных словарь и дерево Фенвика).

\begin{lstlisting}[language=CollectionLang, mathescape=true]
* Map<K, V>
Map.build         :: (t $\to$ (K, V)) $\to$ [t] $\to$ Map<K, V>
Map.get           :: K $\to$ Map<K, V> $\to$ V
Map.add           :: K $\to$ V $\to$ Map<K, V> $\to$ Map<K, V>
Map.size          :: Map<K, V> $\to$ Int

* FenwickTree<T>
FenwickTree.build :: (T $\to$ T') $\to$ Array<T> $\to$ FenwickTree<T> 
FenwickTree.eval  :: Int $\to$ Int $\to$ T'
FenwickTree.get   :: Int $\to$ T
\end{lstlisting}

Все коллекции в некотором приближении можно представлять как списки, а операции над коллекциями --- как преобразования списков. Например, хэш-таблицу можно представлять как список пар $(key, value)$. Преобразования списков выражаются через комбинаторы $filter$, $map$ и $fold$. Таким образом можно ввести <<отношение эквивалентности>> между функциями над коллекциями и преобразованиями списков. Примеры такой эквивалентности приведены ниже:
\begin{lstlisting}[language=CollectionLang, mathescape=true]
Map.build f ks $\sim$ map ($\lambda$k $\to$ (k, f k)) ks
Map.get key xs $\sim$ map snd (filter ($\lambda$(k, v) $\to$ k = key) xs)
\end{lstlisting}

Инварианты и свойства свертки ($fold$) описываются и проверяются значительно труднее, чем свойства $filter$- и $map$-преобразований. В данной работе рассматриваются только функции, выражаемые без использования $fold$. Поэтому многие нетривиальные операции над коллекциями остаются за рамками работы.

Композиции $filter$ и $map$ можно выразить через $mapFilter$ по следующим правилам:

\begin{lstlisting}[language=CollectionLang, mathescape=true, frame=none]
map f (filter p xs)           =  mapFilter p f xs
filter p (map f xs)           =  mapFilter (p $\circ$ f) f xs
filter p' (mapFilter p f xs)  =  mapFilter ($\lambda$x $\to$ p x $\land$ p' x) f xs
map f' (mapFilter p f xs)     =  mapFilter p (f' $\circ$ f) xs
mapFilter p f (filter p' xs)  =  mapFilter ($\lambda$x $\to$ p x $\land$ p' x) f xs
mapFilter p f (map f' xs)     =  mapFilter (p $\circ$ f') (f $\circ$ f') xs
\end{lstlisting}

Таким образом вводится редукция цепочки преобразований к одному $mapFilter$, которая упрощает будущую работу по верификации кандидатов.
% Задача синтезатора: подобрать решение в терминах коллекций и верифицировать его. Для этого все операции над коллекциями редуцируются к $mapFilter$.

Для наглядности рассмотрим пример редукции. Пусть синтезатор подобрал приведенное ниже решение задачи поиска ребер, выходящих из данной вершины (решением является определение запроса, в котором могут использоваться локальные связывания):

\begin{lstlisting}[language=SolutionLang, mathescape=true, frame=none]
findEdges n = Map.get n table where
    table = Map.build ($\lambda$e $\to$ (e.src, filter ($\lambda$e' $\to$ e'.src = e.src) graph)) graph
\end{lstlisting}

Здесь вводится коллекция $table$ типа \lstinline[language=SolutionLang]{Map<Int, List<Edge>>} (тип выводится по Хиндли-Милнеру~\cite{Milner}) и определяется запрос к этой коллекции. Это решение можно редуцировать к $mapFilter$ следующим образом:
\\ 
\\ 
\\ 
\begin{lstlisting}[language=SolutionLang, mathescape=true]
findEdges n
$=$ Map.get n table
$\sim$ Map.get n (Map.build ($\lambda$e $\to$ (e.src, filter ($\lambda$e' $\to$ e'.src = e.src) graph)) graph)
$\sim$ map snd (filter ($\lambda$(src, _) $\to$ src = n) (map ($\lambda$e $\to$
    (e.src, filter ($\lambda$e' $\to$ e'.src = e.src) graph)) graph))
$\sim$ mapFilter ($\lambda$e $\to$ e.src = n) (mapFilter ($\lambda$e' $\to$ e'.src = e.src) id graph) graph
\end{lstlisting}

В данной цепочке преобразования происходят в следующем порядке:
\begin{enumerate}
    \item В исходное определение подставляется локальное связывание ($table$).
    \item Операции над коллекциями ($Map.get$, $Map.build$) приводятся в эквивалентные преобразования списков.
    \item Преобразования списков редуцируются к $mapFilter$.
\end{enumerate}


\subsection{Перебор и верификация кандидатов}
После получения спецификации и обработки синтезатор переходит к перебору и проверке возможных решений (\textit{кандидатов}). Для перебора (поиска) программ-кандидатов многие синтезаторы используют собственные генераторы (например, Cozy~\cite{Cozy}). Генераторы используют различные техники поиска: поиск в глубину, поиск в ширину, поиск с чередованием (interleaving) и так далее.
% Для перебора программ-кандидатов можно написать собственный генератор программ. Так сделано во многих синтезаторах, в т.ч. в Cozy~\cite{Cozy}. Генератор программ может использовать различные виды поиска, например: поиск в глубину, поиск в ширину, поиск с чередованием (interleaving) и т.д.
Однако вместо того чтобы решать задачу с нуля, было решено свести её к задаче SyGuS. Для этого был предложен способ построения спецификаций обоих типов. В качестве синтаксической спецификации строится грамматика, соответствующая функциям над внутренними коллекциями и их эквивалентной записи. Ниже показан небольшой фрагмент такой грамматики:

\begin{lstlisting}[language=SyGuSLang, mathescape=true]
List<Edge>     ::=  graph | Map<K, List<Edge>>.get
Map<K,V>.get   ::=  map snd (filter($\lambda$(k,v) $\to$ k=Obj<K>) Map<K,V>)
Map<K,V>       ::=  Map<K,V>.build
Map<K,V>.build ::=  map ($\lambda$k $\to$ (k, Func<K,V> k)) List<K>
\end{lstlisting}

Эта грамматика описывает построение структур данных через преобразования списков. Она содержит правила для всех используемых синтезатором структур данных и функций над ними.

Нетерминалы в этой грамматике содержат типовые параметры. При этом SyGuS не поддерживает грамматику, снабженную типами, поэтому на следующем этапе данная грамматика специализируется и редуцируется. Редукция происходит таким образом:
\begin{enumerate}
    \item Выбирается правило, соответствующее искомой структуре данных.
    \item Все нетерминалы в его правой части итеративно заменяются на соответствующие им терминальные определения.
    \item Полученное выражение редуцируется к $mapFilter$
\end{enumerate}

Рассмотрим пример. Пусть искомый запрос возвращает значения типа List<Edge> (например, в задаче поиска инцидентных вершин). Тогда из грамматики выбирается правило для List<Edge> и редуцируется так:
\begin{lstlisting}[language=SyGuSLang, mathescape=true]
List<Edge> $\sim$
map snd (filter ($\lambda$(k,v) $\to$ k = Obj<K>) Map<K, List<Edge>>) $\sim$
map snd (filter ($\lambda$(k,v) $\to$ k = Obj<K>) (map ($\lambda$k $\to$ (k, Func<K,List<Edge>> k)) List<K>)) $\sim$
mapFilter ($\lambda$(k,v) $\to$ k = Obj<K>) snd (map ($\lambda$k $\to$ (k, Func<K,List<Edge>>)) List<K>) $\sim$
mapFilter ($\lambda$(k,v) $\to$ k = Obj<K>) Func<K,List<Edge>> List<K>
\end{lstlisting}

Для построения логических ограничений используется та же грамматика. Благодаря $mapFilter$-редукции в итоге всё сводится к проверке эквивалентности двух $mapFilter$: из спецификации и из программы-кандидата:

\begin{lstlisting}[language=SyGuSLang, mathescape=true, frame=none]
mapFilter ($\lambda$e $\to$ e.src = n) id graph /* specification */
mapFilter ($\lambda$(k,v) $\to$ k = Obj<Int>) Func<Int,List<Edge>> graph /* candidate */
\end{lstlisting}

Эквивалетность двух $mapFilter$ проверяется исходя из свойства
\begin{lstlisting}[language=SyGuSLang, mathescape=true, frame=none]
mapFilter p f xs $\sim$ mapFilter p' f' xs $\Longleftrightarrow$ $\forall x: p(x) \leftrightarrow p'(x) \land p(x) \rightarrow (f(x) = f'(x))$
\end{lstlisting}


В конце SyGuS приходит к решению в терминах mapFilter:

\begin{lstlisting}[language=SyGuSLang, mathescape=true, frame=none]
mapFilter ($\lambda$e $\to$ e.src = n) ($\lambda$e $\to$ filter ($\lambda$e' $\to$ e'.src = e.src) graph) graph
\end{lstlisting}

которое эквивалентно решению с использованием конкретных коллекций:
\begin{lstlisting}[language=SolutionLang, mathescape=true, frame=none]
Map.get n (Map.build ($\lambda$e $\to$ (e.src, filter ($\lambda$e' $\to$ e'.src = e.src) graph) ) graph)
\end{lstlisting}


\subsection{Реализация}
Для реализации прототипа ядра синтезатора был выбран язык Haskell. Этот язык, благодаря мощной системе типов и механизму сопоставления с образцом (pattern-matching), отлично подходит для работы с синтаксическими деревьями и прототипированием языковых инструментов.
Парсер языка спецификаций написан с помощью библиотеки монадических парсер-комбинаторов Parsec~\cite{parsec2001}.
%Парсер-комбинаторы являются более гибким и выразительным механизмом, чем другие подходы к созданию парсеров (например, написание парсера с нуля или использование генераторов парсеров).
Помимо парсера, для языка спецификации были реализованы: pretty-printer, редукция к $mapFilter$, вывод типов (по Хиндли-Милнеру). Также был написан конвертер программ-решений в формат JSON для последующей обработки генератором кода.
% Пока не придумал, что сказать ещё по поводу реализации редукции и т.п. Подумаю ещё

\begin{figure}[h]
\caption{Схема работы синтезатора}
\centering
\includegraphics[width=\textwidth]{diag}
\end{figure}

На рисунке показана схема работы всего синтезатора. Сначала пользователь задает спецификацию требуемой структуры данных. По спецификации строится её дерево разбора, которое затем редуцируется к $mapFilter$. Далее по полученному представлению спецификации строится грамматика и логические ограничения для SyGuS. Полученные ограничения передаются SyGuS-решателю, который возвращает искомую структуру данных в некотором внутреннем представлении. Это представление конвертируется в формат JSON и передается генератору кода. В результате пользователь получает реализацию требуемой структуры данных на заданном им языке программирования.

\section{Заключение}
В ходе данной работы получены следующие результаты:
\begin{enumerate}
    \item Исследована активно развивающаяся предметная область --- синтез программ.
    \item Спроектирован язык спецификации структур данных.
    \item Разработан алгоритм синтеза.
    \item Разработан прототип ядра синтезатора.
\end{enumerate}

Исходный код прототипа ядра доступен на GitHub~\footnote{\url{https://github.com/ortem/CollectionSynthesis}}.

\subsection*{Будущие исследования}
В будущем планируется добавить поддержку комбинатора $fold$, так как без него невозможно выразить многие нетривиальные операции над коллекциями (например, сортировку).
Добавление $fold$ позволит синтезатору использовать больше структур данных и операций над ними.

Также, поскольку данная работа скорее теоретическая и реализован лишь прототип ядра синтезатора, необходимо соединить воедино ядро с генератором кода и сравнить полученный синтезатор с существующими.


\setmonofont[Mapping=tex-text]{CMU Typewriter Text}
\bibliographystyle{ugost2008ls}
\bibliography{diploma.bib}
\end{document}


