\documentclass[14pt]{matmex-diploma}
\usepackage{syntax}
\usepackage{listings}

\lstdefinelanguage{Synthesizer}
{
  morekeywords={ Int, String, Bool, record, Collection, query, update, or, and, of },
  morecomment=[l]{--}, % l is for line comment
  morecomment=[s]{/*}{*/}, % s is for start and end delimiter
  morestring=[b]" % defines that strings are enclosed in double quotes
}
\lstdefinestyle{Synth} {
    language        = Synthesizer,
    basicstyle      = \footnotesize\ttfamily,
    identifierstyle = \color{black},
    commentstyle    = \color{green},
    keywordstyle    = \color{blue},
    stringstyle     = \color{red},
    extendedchars   = true,
    tabsize         = 4,
    showspaces      = false,
    showstringspaces = false,
    breakautoindent = true,
    flexiblecolumns = true,
    keepspaces      = true,
    stepnumber      = 0,
    xleftmargin     = 0pt
}
\lstset{
    style=Synth,
    breaklines=false,
    frame=single
}



\begin{document}
% Год, город, название университета и факультета предопределены,
% но можно и поменять.
% Если англоязычная титульная страница не нужна, то ее можно просто удалить.
\filltitle{ru}{
    chair              = {Кафедра системного программирования},
    title              = {Синтез структур данных},
    % Здесь указывается тип работы. Возможные значения:
    %   coursework - Курсовая работа
    %   diploma - Диплом специалиста
    %   master - Диплом магистра
    %   bachelor - Диплом бакалавра
    type               = {coursework},
    position           = {студента},
    group              = 344,
    author             = {Мухин Артем Михайлович},
    supervisorPosition = {программист JetBrains},
    supervisor         = {Мордвинов Д.\,А.},
    reviewerPosition   = {},
    reviewer           = {},
    chairHeadPosition  = {профессор},
    chairHead          = {Терехов А.\,Н.},
%   university         = {Санкт-Петербургский Государственный Университет},
%   faculty            = {Математико-механический факультет},
%   city               = {Санкт-Петербург},
%   year               = {2013}
}
\filltitle{en}{
    chair              = {Software Engineering Chair},
    title              = {Data Structure Synthesis},
    author             = {Artem Mukhin},
    supervisorPosition = {},
    supervisor         = {Dmitry Mordvinov},
    reviewerPosition   = {},
    reviewer           = {},
    chairHeadPosition  = {professor},
    chairHead          = {Andrey Terekhov},
}
\maketitle
\tableofcontents
% У введения нет номера главы
\section*{Введение}
Во многих программах используются специальные структуры данных, не содержащиеся явно в стандартных библиотеках языков программирования. Таковыми являются структуры, составленные из известных коллекций с помощью композиции или изменения некоторых свойств. Реализация таких структур —-- монотонная и сложная работа, в ходе которой зачастую возникают ошибки как на этапе подбора оптимальных структур (т.к для этого программисту необходимо знать асимптотики различных операций над структурами данных), так и на этапе реализации. Поэтому программистам был бы полезен инструмент, позволяющий по короткой декларативной спецификации автоматически получить исходный код оптимальной и корректной реализации структуры данных.

Синтез программ --- это задача автоматического поиска программы, написанной на заданном языке программирования и удовлетворяющей некоторым ограничениям, которые задает пользователь. В отличие от трансляторов, синтезаторы осуществляют поиск требуемой программы в пространстве всех возможных программ, а не просто переводят программу с одного языка на другой. Ограничения на требуемую программу могут быть спецификацией на некотором промежуточном языке, примерами ввода-вывода, описанием на естественном языке, частично написанными программами и т.д. Синтезатор структур данных --- это инструмент, позволяющий получить реализацию (на заданном пользователем языке программирования) автоматически сконструированной структуры данных.

В последние годы было предпринято несколько попыток создать синтезаторы структур данных. Однако существующие синтезаторы еще далеки от совершенства: они позволяют создавать структуры данных только для определенного узкого класса задач (например, структуры данных с запросами-фильтрациями~\cite{Cozy}). Поэтому усовершенствование текущих подходов к синтезу структур данных является актуальной проблемой.

\section{Постановка задачи}
Целью данной работы является создание синтезатора структур данных, подходящего для более широкого класса задач, чем существующие. Для этого были поставлены следующие задачи:
\begin{itemize}
    \item исследовать существующие подходы к синтезу программ;
    \item спроектировать декларативный язык спецификации структур данных, достаточно мощный для описания нетривиальных задач;
    \item разработать алгоритм синтеза структур данных;
    \item сравнить получившийся синтезатор с существующими.
\end{itemize}
По проекту ведется параллельная курсовая работа. Автор данной курсовой работы занимается созданием ядра синтезатора, а его коллега --- реализацией структур данных и генерацией кода. На рисунке представлена предполагаемая архитектура нашего синтезатора. 
\begin{figure}[h]
\caption{Архитектура синтезатора}
\centering
\includegraphics[width=0.6\textwidth]{ud3}
\end{figure}


\section{Обзор}
Синтез программ является одной из наиболее значимых проблем информатики и искусственного интеллекта. Успешное решение этой задачи требует преодоления двух основных проблем:
\begin{enumerate}
    \item необходимо предоставить пользователю достаточно простой и удобный способ спецификации желаемой программы, который не был бы слишком сложен для компьютера;
    \item синтез программ --- сложнейшая комбинаторная проблема; во избежание взрыва количества программ приходится как можно сильнее сокращать пространство перебора.
\end{enumerate}
Исторически реализация синтезаторов программ стала возможной после появления инструментов для автоматического доказательства теорем.
\subsection{Дедуктивный синтез}
Первые подходы~\cite{deductive1},~\cite{Zohar} к синтезу программ были основаны на дедукции. Идея \emph{дедуктивного синтеза} --- автоматически доказать заданную пользователем спецификацию и затем использовать это доказательство для конструирования подходящей программы. Основной минус этого подхода заключается в том, что пользователю приходится составлять полную и формальную спецификацию, что во многих случаях не проще, чем написать требуемую программу вручную.
\subsection{Индуктивный синтез}
Для упрощения предварительной работы пользователя был придуман метод \emph{индуктивного синтеза}. В этом подходе вместо полных спецификаций программы используются индуктивные ограничения, такие как примеры ввода-вывода и демонстрации работы программы. В 1970-е годы этот подход был реализован в нескольких инструментах для синтеза небольших программ на языке LISP~\cite{Shaw}. Сегодня для синтеза программ чаще применяют техники, сочетающие в себе и дедуктивный, и индуктивный подходы.
\subsection{Синтез, управляемый оракулом}
Одним из современных подходов является синтез на основе \emph{частично написанных программ} (программ с <<дырками>>). В качестве спецификации желаемой программы выступает некоторый каркас, содержащий некоторые заглушки, на место которых синтезатор должен подставить сгенерированные им выражения языка, а также ограничения в виде \emph{утверждений} (assertions), которым должна удовлетворять итоговая программа. Первой известной реализацией этого подхода является инструмент Sketch~\cite{Solar-Lezama}, созданный в 2008 году.
Важнейшей находкой автора Sketch является следующее наблюдение: в отличие от синтеза, задачи второго порядка, верификация программ является задачей первого порядка и решается гораздо проще. При этом задача синтеза программы сводится к верификации программ, полученных генератором произвольных программ на фиксированном языке. Для каждого очередного кандидата требуется найти конструктивный контрпример, который в дальнейшем используется как дополнительное ограничение на искомую программу. Такой подход получил название \emph{CEGIS} (counterexample-guided inductive synthesis).

Также стоит упомянуть инструмент для синтеза преобразований списков ${\lambda}^2$~\cite{Lambda2}. Этот синтезатор принимает на вход несколько примеров преобразований списка или дерева и возвращает функцию, удовлетворяющую этим примерам. ${\lambda}^2$ получился достаточно мощным, чтобы синтезировать весьма нетривиальные операции, такие как декартово произведение списков и удаление дубликатов из списка. Данная работа интересна тем, что сочетает сразу несколько техник синтеза: индукцию для обобщения входных примеров; дедукцию для опровержения и генерации новых примеров; заполнение <<дырок>> в промежуточных программах-кандидатах.

\subsection{FlashFill}
На сегодняшний день одним из наиболее известных и успешных коммерческих продуктов, использующих синтез программ (а именно --- индуктивный синтез на основе примеров), является Microsoft Excel с технологией FlashFill~\cite{FlashFill}. Эта технология позволяет автоматически синтезировать программу, выполняющую преобразования над данными в ячейках электронной таблицы, основываясь на нескольких примерах, выполненных пользователем вручную. Таким образом, пользователю достаточно заполнить несколько первых ячеек столбца, после чего FlashFill предложит заполнить остальные ячейки самостоятельно в соответствии с пользовательскими примерами.
\subsection{Синтез структур данных}
Перейдем к обзору решений задачи синтеза структур данных.

В 1970-е годы задача выбора оптимальной реализации структуры данных была рассмотрена во время проектирования языка SETL, ориентированного на работу с множествами~\cite{setl}. Для улучшения производительности требовалось выбрать наиболее оптимальные для конкретных задач реализации структур данных множество и словарь.

Кроме того, были попытки синтезировать структуры данных с помощью реляционной алгебры (например, RelC~\cite{RelC}).

Работа, представляющая для нас наибольший интерес, --- это синтезатор структур данных Cozy~\cite{Cozy}. Авторы данной работы предложили подход к синтезу структур данных, основанный на идее CEGIS. С помощью Cozy работа программиста сводится к описанию требуемой ему структуры данных на языке спецификации высокого уровня, а поиск и реализацию подходящих структур данных берет на себя синтезатор. Cozy имеет довольно скудный язык спецификации и способен решать некоторые несложные задачи, а именно --- фильтрацию элементов коллекции по предикатам, содержащим только имена переменных, полей и знаки сравнения.

\section{Текущие результаты}
На данный момент собрана некоторая коллекция задач, потенциально подходящих для синтеза. Первоначально планировалось использовать задачи из соревнований по олимпиадному программированию, т.к. многие из таких задач требуют использования нетривиальных структур данных. Но основной минус таких задач для нас --- их алгоритмическая составляющая. Большинство олимпиадных задач помимо использования структур данных подразумевают также применение каких-либо эвристик или нетривиальных <<трюков>>, до которых потенциально может догадаться только человек. Тем не менее, мы выбрали несколько алгоритмически простых задач на нетривиальные структуры данных: дерево отрезков, декартово дерево, корневая декомпозиция отрезка, а также на более известные коллекции: приоритетная очередь, дерево поиска, ассоциативные контейнеры (все эти структуры планируется добавить в наш синтезатор).

Также был спроектирован начальный вариант языка спецификации, позволяющий описать эти задачи. Ниже приведена грамматика текущей версии нашего языка спецификации:
%\begin{grammar}
%<predicate> ::= True | False 
%\alt <var> <comparison> <var> 
%\alt <predicate> And <predicate> \alt <predicate> Or <predicate>
%\alt Not <predicate>
%\end{grammar}

%\begin{grammar}
%<var> ::= <field> | <query-var>
%\end{grammar}

%\begin{grammar}
%<comparison> ::= `==' | `>' | `>=' | `<' | `<=' | `!='
%\end{grammar}

\begin{grammar}
<specification> ::= <record_decls> <collection_decl> <queries>
\end{grammar}

\begin{grammar}
<record_decl> ::= record <name> \{ <fields> \}
\end{grammar}

\begin{grammar}
<collection_decl> ::= <name>: Collection of <name>
\alt <name>: IndexedCollection of <name>
\end{grammar}

\begin{grammar}
<fields> ::= <field> | <field>, <fields>
\end{grammar}

\begin{grammar}
<field> ::= <name>: <type>
\end{grammar}

\begin{grammar}
<query> ::= query <name>(<parameters>) = <body>
\end{grammar}

\begin{grammar}
<body> :: = <name> | <func> <body>
\end{grammar}

\begin{grammar}
<func> ::= filter <f> | map <f> | min <f> | max <f> | sort <f> | size
\end{grammar}

\begin{grammar}
<paramters> ::= <parameter> | <parameter>, <parameters>
\end{grammar}

\begin{grammar}
<paramter> ::= <name>: <base_type>
\end{grammar}

\begin{grammar}
<type> ::= Int | Float | String | Bool
\end{grammar}

Для демонстрации возможностей языка рассмотрим задачу поиска инцидентных данной вершине дуг в графе, спецификация которой приведена в Листинге~\ref{lst:graph}.

\begin{lstlisting}[caption={Поиск инцидентных данной вершине дуг в графе},captionpos=t,label={lst:graph}]
record Edge { src: Int, dst: Int }
graph: Collection of Edge
query findEdges(node: Int) =
    filter (\edge -> edge.src == node || edge.dst == node) graph
\end{lstlisting}

Спецификация состоит из объявлений типов записей (элементов коллекций) и типов коллекций, а также из определений запросов к коллекциям. Синтаксис определения запросов во многом подобен синтаксису языка Haskell. Пользователь может использовать функции и комбинаторы из заранее заданного набора: $filter$, $map$, $fold$, $min$, $max$, $size$, $sort$. Функции, передаваемые комбинаторам, могут содержать арифметические операторы, сравнение, использование значений полей записей и параметров запроса.

Чтобы отметить преимущества нашего языка, рассмотрим грамматику языка спецификации Cozy:

\begin{grammar}
<predicate> ::= True | False 
\alt <var> <comparison> <var> 
\alt <predicate> And <predicate> \alt <predicate> Or <predicate>
\alt Not <predicate>
\end{grammar}

\begin{grammar}
<var> ::= <field> | <query-var>
\end{grammar}

\begin{grammar}
<comparison> ::= `==' | `>' | `>=' | `<' | `<=' | `!='
\end{grammar}
Язык Cozy имеет несколько проблем.

Во-первых, на этом языке возможно описать только запросы-фильтрации (вернуть элементы коллекции, удовлетворяющие предикату). Мы хотели бы иметь язык, достаточно богатый для описания запросов более сложных видов. Поэтому язык должен поддерживать не только filter, но и, по крайней мере, map (т.к. многие задачи подразумевают не просто получение элементов коллекции, но и выполнение каких-либо действий над этими элементами).

Во-вторых, язык Cozy не поддерживает арифметику. Учитывая мощности современных SMT-решателей, добавление линейной арифметики выглядит возможным. Поэтому мы планируем поддерживать линейную арифметику в спецификациях.


\setmonofont[Mapping=tex-text]{CMU Typewriter Text}
\bibliographystyle{ugost2008ls}
\bibliography{diploma.bib}
\end{document}