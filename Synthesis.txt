*** graph problem from cozy ***

record Edge { src: Int, dst: Int }
graph: SetOf<Edge>
query findEdges(n: int) = filter (\e -> e.src == n || e.dst == n) graph

findEdges:
  get= "src"
  get= "dst"
  -- минимизировать время вычисления get= по нескольким полям =>
  -- подходят несколько ассоциативных коллекций по каждому из полей
  -- если поле unique, то Map<Int, Edge>
  -- иначе Map<Int, List<Edge>> aka HashTable<Int, Edge>

-------------------------------------------------------
*** top frequent word ***

record Word { value: String }
words: Collection<Word>
query count(val: String) = size (filter (\w -> w.value == val) words)
query topFrequent() =  maximize (\w -> count w.value) words

count:
  f (get=), где f :: Record -> Any
  -- минимизировать время вычисления f (get=) =>
  -- подходит Map<string, Int> (s -> f(s))

topFrequent:
  max/min (comparator), где comparator :: Record -> Number
  -- минимизировать время вычисления max (comparator) =>
  -- нужна структура, позволяющая максимизировать какую-то функцию =>
  -- какая-то приоритетная очередь

-------------------------------------------------------
*** 03A ***

record Number { unique value: Int, unique index: Int }
numbers: Collection<Number>

query swapGet(val1: Int, val2: Int) =
  abs (numbers.get("value", val1).index - numbers.get("value", val2).index)

update swapSet(v1: Int, v2: Int) =
  numbers <- numbers.set("value", val1, "index", numbers.get("value", val2))
                    .set("value", val2, "index", numbers.get("value", val1))

swapGet:
  get= "value"
  -- подходит Map<Int, Number>

swapSet:
  -- number.set(...) на низком уровне реализуется через get=,
  -- поэтому с точки зрения cost-модели set ~ get=
  get= "value"
  -- аналогично подходит Map<Int, Number>

---------------------------------------------------
*** basic-or cozy ***

record Person { age: Int, name: String }
persons: Collection<Person>

query q(minAge: int, theName: String) =
  persons
  |> filter (\p -> p.age > minAge || p.name == theName)

q:
  get> "age"
  get= "name"

Collection.union
  filter (\p -> p.age > minAge) persons
  filter (\p -> p.name == theName) persons
Collection.concat
  filter (\p -> p.age > minAge) persons                           SortedCollection<Person, (p.age)>
  filter (\p -> p.name == theName && p.age <= minAge) persons     Map<String, Sorted<Person, (p.age asc)>>

Если запрос имеет вид filter, состоящего только из ==, то оптимальное решение -- привести запрос в DNF и построить несколько Map:
filter (\r -> (r.v1 == v1 && r.v2 == v2) || (r.v3 == v3 && r.v4 == v4 && r.v5 == v5) || ...) ~
Map<Tuple(v1, v2), List<Record>>        линейный поиск (\r -> !(остальное))
Map<Tuple(v3, v4, v5), List<Record>>    линейный поиск (\r -> !(остальное))
...

filter (\r -> r.v1 == v1 && r.v2 == v2 && r.v3 < v3 && r.v4 > v4 && ...) ~
Map<Tuple(v1, v2), Sorted<Record, (...)>>   бинпоиск

filter (\r -> r.v1 < v1 || r.v2 > v2 || ...) ~
Sorted<Record, (...)>
Sorted<Record, (...)>
... (2^n)

---------------------------------------------------

record R { value1: Int, value2: Int }
records: Collection<Record>

query q(val1: Int, val2: Int) =
  numbers
  |> filter (\r -> r.value1 < val1 && r.value2 < val2)
  |> map (\r -> r.value1 * r.value2) 
  |> max

q:
  get< "value1"
  get< "value2"